import { buntstift } from 'buntstift';
import { fileURLToPath } from 'url';
import path from 'path';
import { Worker } from 'worker_threads';
import { error, value } from 'defekt';
import * as errors from '../errors';
const dirname = path.dirname(fileURLToPath(import.meta.url));
class TestRunner {
    applicationRoot;
    bail;
    watch;
    worker;
    previousRunResult;
    runNumber;
    constructor({ applicationRoot, bail, watch }) {
        this.applicationRoot = applicationRoot;
        this.bail = bail;
        this.watch = watch;
        this.worker = undefined;
        this.runNumber = 0;
    }
    async run({ absoluteTestFilesPerType, typeSequence, grep }) {
        this.worker = new Worker(path.join(dirname, '..', 'steps', 'test', 'testWorker.js'), {
            workerData: {
                applicationRoot: this.applicationRoot,
                absoluteTestFilesPerType,
                typeSequence,
                bail: this.bail,
                watch: this.watch,
                grep,
                previousRunResult: this.previousRunResult,
                runNumber: this.runNumber
            }
        });
        this.runNumber += 1;
        let result = error(new errors.TestsFailed());
        const terminateWorker = async () => {
            await this.worker.terminate();
        };
        process.on('SIGTERM', terminateWorker);
        await new Promise((resolve, reject) => {
            this.worker.once('message', async (message) => {
                if (message === 'success') {
                    this.previousRunResult = 'success';
                    result = value();
                }
                else if (message === 'bail') {
                    this.previousRunResult = 'bail';
                }
                else {
                    this.previousRunResult = 'fail';
                }
                this.worker.stdout.once('end', async () => {
                    await this.worker.terminate();
                });
                this.worker.stderr.once('end', async () => {
                    await this.worker.terminate();
                });
                setTimeout(async () => {
                    await this.worker.terminate();
                }, 30_000);
            });
            this.worker.once('error', (workerError) => {
                reject(workerError);
            });
            this.worker.once('exit', async () => {
                resolve();
            });
        });
        process.off('SIGTERM', terminateWorker);
        return result;
    }
    async abort() {
        buntstift.line();
        buntstift.info('Aborting current test run...');
        if (this.worker) {
            await this.worker.terminate();
        }
    }
}
export { TestRunner };
