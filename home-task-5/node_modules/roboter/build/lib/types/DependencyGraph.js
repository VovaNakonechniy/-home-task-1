import { error, value } from 'defekt';
import * as errors from '../errors';
class DependencyGraph {
    roots;
    edges;
    backEdges;
    constructor() {
        this.roots = new Set();
        this.edges = new Map();
        this.backEdges = new Map();
    }
    addRoot(filePath) {
        if (this.roots.has(filePath)) {
            return error(new errors.RootAlreadyInGraph());
        }
        this.roots.add(filePath);
        return value();
    }
    removeRoot(filePath) {
        if (!this.roots.has(filePath)) {
            return error(new errors.RootNotInGraph());
        }
        this.roots.delete(filePath);
        if (this.edges.has(filePath)) {
            for (const target of this.edges.get(filePath)) {
                this.removeEdge(filePath, target).unwrapOrThrow();
            }
        }
        return value();
    }
    hasRoot(filePath) {
        return this.roots.has(filePath);
    }
    addEdge(source, target) {
        if (!this.hasNode(source)) {
            return error(new errors.SourceNodeNotInGraph());
        }
        const edgesFromSource = this.edges.get(source) ?? new Set();
        if (edgesFromSource.has(target)) {
            return error(new errors.EdgeAlreadyInGraph());
        }
        edgesFromSource.add(target);
        this.edges.set(source, edgesFromSource);
        const backEdgesFromTarget = this.backEdges.get(target) ?? new Set();
        backEdgesFromTarget.add(source);
        this.backEdges.set(target, backEdgesFromTarget);
        return value();
    }
    updateEdgesFromNode(source, targets) {
        if (!this.hasNode(source)) {
            return error(new errors.SourceNodeNotInGraph());
        }
        if (!this.edges.has(source)) {
            this.edges.set(source, new Set());
        }
        const currentEdges = this.edges.get(source);
        const newEdges = new Set();
        const obsoleteEdges = new Set();
        for (const target of targets) {
            if (currentEdges.has(target)) {
                continue;
            }
            newEdges.add(target);
        }
        for (const currentEdge of currentEdges) {
            if (targets.has(currentEdge)) {
                continue;
            }
            obsoleteEdges.add(currentEdge);
        }
        for (const newEdge of newEdges) {
            this.addEdge(source, newEdge);
        }
        for (const obseleteEdge of obsoleteEdges) {
            this.removeEdge(source, obseleteEdge);
        }
        return value();
    }
    removeEdge(source, target) {
        if (!this.edges.get(source)?.has(target)) {
            return error(new errors.EdgeNotInGraph());
        }
        this.edges.get(source).delete(target);
        this.backEdges.get(target).delete(source);
        if (this.backEdges.get(target).size === 0) {
            this.removeNode(target).unwrapOrThrow();
            this.backEdges.delete(target);
        }
        return value();
    }
    removeNode(filePath) {
        if (this.hasRoot(filePath)) {
            return error(new errors.CannotImplicitlyRemoveRoots());
        }
        if (!this.hasNode(filePath)) {
            return error(new errors.NodeNotInGraph());
        }
        const edgesFromNode = this.edges.get(filePath);
        // Not all nodes in the graph have a collection of outgoing edges. If there
        // is none, we are done here.
        if (!edgesFromNode) {
            return value();
        }
        for (const target of edgesFromNode) {
            this.removeEdge(filePath, target).unwrapOrThrow();
        }
        this.edges.delete(filePath);
        return value();
    }
    // Every node in the graph is either a root node or the source of a back-edge.
    hasNode(filePath) {
        if (this.roots.has(filePath)) {
            return true;
        }
        if (this.backEdges.has(filePath)) {
            return true;
        }
        return false;
    }
    findRoots(filePath) {
        if (!this.hasNode(filePath)) {
            return error(new errors.NodeNotInGraph());
        }
        if (this.hasRoot(filePath)) {
            return value(new Set([filePath]));
        }
        const visitedDependents = new Set();
        const currentDependents = [filePath];
        const foundRoots = new Set();
        while (currentDependents.length > 0) {
            const currentDependent = currentDependents.pop();
            const nextDependents = this.backEdges.get(currentDependent);
            for (const nextDependent of nextDependents) {
                if (visitedDependents.has(nextDependent)) {
                    continue;
                }
                if (this.hasRoot(nextDependent)) {
                    foundRoots.add(nextDependent);
                    continue;
                }
                currentDependents.push(nextDependent);
            }
            visitedDependents.add(currentDependent);
        }
        return value(foundRoots);
    }
    prettyPrint() {
        const filePaths = [...this.edges.keys()];
        filePaths.sort((left, right) => left.localeCompare(right));
        let stringRepresentation = '';
        for (const filePath of filePaths) {
            stringRepresentation += `${filePath} =>\n`;
            for (const importPath of this.edges.get(filePath)) {
                stringRepresentation += `  ${importPath}\n`;
            }
        }
        return stringRepresentation;
    }
}
export { DependencyGraph };
