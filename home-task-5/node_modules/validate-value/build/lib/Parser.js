"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const getByInstancePath_1 = require("./getByInstancePath");
const ParseError_1 = require("./ParseError");
const typedescriptor_1 = require("typedescriptor");
const ajv_1 = __importDefault(require("ajv"));
const defekt_1 = require("defekt");
const ajvInstance = new ajv_1.default({
    allowUnionTypes: true
});
ajv_formats_1.default(ajvInstance);
ajvInstance.addFormat('alphanumeric', /[a-zA-Z0-9]/u);
class Parser {
    constructor(schema) {
        this.validateInternal = ajvInstance.compile(schema);
    }
    parse(unparsedValue, { valueName = 'value', separator = '.' } = {}) {
        const isValid = this.validateInternal(unparsedValue);
        if (isValid) {
            return defekt_1.value(unparsedValue);
        }
        const validationError = this.validateInternal.errors[0];
        const failingValue = getByInstancePath_1.getByInstancePath({ object: unparsedValue, instancePath: validationError.instancePath });
        let updatedPath = `${valueName}${validationError.instancePath.replace(/\//gu, separator)}`;
        let message = 'Parsing failed';
        switch (validationError.keyword) {
            case 'required': {
                const missingPropertyName = validationError.params.missingProperty;
                message = `Missing required property: ${missingPropertyName}`;
                updatedPath += `${separator}${missingPropertyName}`;
                break;
            }
            case 'additionalProperties': {
                const additionalPropertyName = validationError.params.additionalProperty;
                message = `Unexpected additional property: ${additionalPropertyName}`;
                updatedPath += `${separator}${additionalPropertyName}`;
                break;
            }
            case 'minLength': {
                const minPropertyLength = validationError.params.limit;
                const actualLength = failingValue.length;
                message = `String is too short (${actualLength} chars), minimum ${minPropertyLength}`;
                break;
            }
            case 'maxLength': {
                const maxPropertyLength = validationError.params.limit;
                const actualLength = failingValue.length;
                message = `String is too long (${actualLength} chars), maximum ${maxPropertyLength}`;
                break;
            }
            case 'minimum': {
                const minimumValue = validationError.params.limit;
                const actualValue = failingValue;
                message = `Value ${actualValue} is less than minimum ${minimumValue}`;
                break;
            }
            case 'maximum': {
                const maximumValue = validationError.params.limit;
                const actualValue = failingValue;
                message = `Value ${actualValue} is more than maximum ${maximumValue}`;
                break;
            }
            case 'enum': {
                const { allowedValues } = validationError.params;
                const actualValue = failingValue;
                message = `No enum match (${actualValue}), expects: ${allowedValues.join(', ')}`;
                break;
            }
            case 'pattern': {
                const { pattern } = validationError.params;
                message = `String does not match pattern: ${pattern}`;
                break;
            }
            case 'minItems': {
                const { limit } = validationError.params;
                const actualCount = failingValue.length;
                message = `Array is too short (${actualCount}), minimum ${limit}`;
                break;
            }
            case 'maxItems': {
                const { limit } = validationError.params;
                const actualCount = failingValue.length;
                message = `Array is too long (${actualCount}), maximum ${limit}`;
                break;
            }
            case 'format': {
                const { format } = validationError.params;
                message = `Value does not satisfy format: ${format}`;
                break;
            }
            case 'type': {
                const { type } = validationError.params;
                const actualType = typedescriptor_1.typeOf(failingValue);
                message = `Invalid type: ${actualType} should be ${Array.isArray(type) ? type.join(', ') : type}`;
                break;
            }
            default: {
                // Intentionally left blank.
            }
        }
        return defekt_1.error(new ParseError_1.ParseError({
            message: `${message} (at ${updatedPath}).`,
            originalValue: unparsedValue,
            origin: validationError
        }));
    }
    isValid(unparsedValue) {
        const isValid = this.validateInternal(unparsedValue);
        if (isValid) {
            return true;
        }
        return false;
    }
}
exports.Parser = Parser;
